package Graph;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Random;
import java.util.Scanner;

import Exporting.FileHandler;
import Random.BlumBlumShub;

import java.util.Set;

public class Main {
    private static final int MAX_NODES = 15;
    private static final int MIN_NODES = 3;

    /**
     * Helper method to generate a new graph.
     * @param extraRand bitNum for BlumBlumShub
     * @return The generated graph
     */
    public DiWeGraph<Integer> generateGraph(int extraRand){
        System.out.print("Generating a Random BlumBlumShub Graph with ");
        BlumBlumShub BBS = new BlumBlumShub();
        Set<Integer> nodesSet;
        Random random = new Random();

        int numNodes = random.nextInt(MAX_NODES - MIN_NODES + 1) + MIN_NODES;
        System.out.println(numNodes + " vertices.");
        int nodeCount = numNodes;

        BBS.setUp();
        DiWeGraph<Integer> graph = new DiWeGraph<Integer>();

        // Ensure the exact number of nodes determined by numNodes is generated (otherwise, it will lead to
        // an index out of bounds exception.
        do {
            nodesSet = BBS.buffer(numNodes, extraRand);
        } while (nodesSet.size() < numNodes);

        ArrayList<Integer> nodes = new ArrayList<>(nodesSet); // Convert to an array list for easier use

        // Set all integer values generated by the BBS algorithm to be node vertices in the graph
        for(Integer node : nodes){
            System.out.println("Node " + node);
            graph.addVertex(new Node<Integer>(node));
            nodeCount -= 1;
        }

        // For each vertex in the graph, randomly generate between 0 and 2 (MIN_NODES in the graph - 1) edges
        for (Node<Integer> vertex : graph.getGraph()){
            int numEdges = random.nextInt(MIN_NODES);

            for(int edge = 0; edge < numEdges; edge++){
                Integer n1 = nodes.get((random.nextInt(numNodes - MIN_NODES + 1) + MIN_NODES) - 1);
                Node<Integer> node1 = graph.findInputInGraph(n1);
                Integer n2 = nodes.get((random.nextInt(numNodes - MIN_NODES + 1) + MIN_NODES) - 1);
                Node<Integer> node2 = graph.findInputInGraph(n2);

                // regenerate node2 if node is trying to point to itself to better display findCycle functionality
                while (Objects.equals(n1, n2)){
                    n2 = nodes.get((random.nextInt(numNodes - MIN_NODES + 1) + MIN_NODES) - 1);
                    node2 = graph.findInputInGraph(n2);
                }

                graph.addEdge(node1,node2,BBS.nextByte(extraRand));
            }
        }

        // Print the generated graph and then return it
        System.out.println("\n==============================================================");
        graph.printGraph();
        System.out.println("================================================================\n");
        return graph;
    }

    public static void main(String[] args) throws IOException {
        Main main = new Main();
        FileHandler<Integer> file = new FileHandler<>();
        String graphFileName;
        DiWeGraph<Integer> graph = null;
        Scanner scanner = new Scanner(System.in);
        ArrayList<Path<Integer>> paths = new ArrayList<>();

        System.out.println("Lets start by making a random graph!");
        graph = main.generateGraph(11);

        while(true){
            System.out.println("\nWould you like to: \n1. make a new graph\n2. get a path from graph\n3. get a cycle from graph\n4. exit this program");
            int input = scanner.nextInt();

            switch (input){
                case 1:
                    // Export existing graph before generating a new one
                    System.out.println("Exporting graph...");
                    System.out.println("What do you want to call your file? (Cannot overwrite so pick a new name if you already exported a graph): ");
                    graphFileName = scanner.next();
                    Cycle<Integer> cycle = new DirectedCycle<Integer>();
                    cycle.findCycle(graph);
                    file.exportGraph(graphFileName, graph, cycle, paths);

                    paths.clear(); // reset the paths before generating a new graph

                    // Generate a new graph
                    System.out.println("Please give me a number just to make the graph extra random. (At least 5, Less than 25): ");
                    // Force extra to be at least 4 because any lower bitNum value will not be able to generate at least 15
                    // unique vertex values for the graph (our max number of nodes for the graph).
                    int extra = scanner.nextInt();
                    while (extra < 5 || extra > 25){
                        System.out.println("Invalid input. You must enter an integer that's at least 5 and less than 25.");
                        System.out.println("Please give me a number just to make the graph extra random. (At least 5): ");
                        extra = scanner.nextInt();
                    }

                    graph = main.generateGraph(extra);
                    break;
                case 2:
                    // Find a path from one node to another
                    System.out.println("Start of Path? Number please.");
                    Integer start = scanner.nextInt();
                    Node<Integer> start_node = graph.findInputInGraph(start);

                    System.out.println("End of Path? Number please.");
                    Integer end = scanner.nextInt();
                    Node<Integer> end_node = graph.findInputInGraph(end);

                    System.out.println("Checking graph for path...");
                    Path<Integer> path = graph.findPath(start_node, end_node); //going to be using helper class once made to fix
                    if (path != null){
                        path.printPath();
                        paths.add(path);
                    }
                    break;
                case 3:
                    System.out.println("Checking graph for cycle...");
                    Cycle<Integer> cyclePrint = new DirectedCycle<Integer>();
                    cyclePrint.findCycle(graph);
                    break;
                case 4:
                    System.out.println("Exiting Program...");
                    return;
                default:
                    System.out.println("Invalid Entry. Please try again.");
            }
        }

    }
}